diff --git a/stan/lib/stan_math/fwd/core/operator_multiplication.hpp b/stan/lib/stan_math/fwd/core/operator_multiplication.hpp
index baf5e118e5f..02bd9ae87ea 100644
--- a/stan/lib/stan_math/fwd/core/operator_multiplication.hpp
+++ b/stan/lib/stan_math/fwd/core/operator_multiplication.hpp
@@ -2,6 +2,7 @@
 #define STAN_MATH_FWD_CORE_OPERATOR_MULTIPLICATION_HPP

 #include <stan/math/fwd/core/fvar.hpp>
+#include <stan/math/prim/core/operator_multiplication.hpp>

 namespace stan {
 namespace math {
@@ -45,6 +46,51 @@ inline fvar<T> operator*(const fvar<T>& x, double y) {
   return fvar<T>(x.val_ * y, x.d_ * y);
 }

+/**
+ * Return the product of the two complex fvar<T> arguments.
+ *
+ * @tparam value and tangent type for variables
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+template <typename T>
+inline std::complex<stan::math::fvar<T>> operator*(
+    const std::complex<stan::math::fvar<T>>& x,
+    const std::complex<stan::math::fvar<T>>& y) {
+  return internal::complex_multiply(x, y);
+}
+
+/**
+ * Return the product of std::complex<double> and
+ * std::complex<fvar<T>> arguments.
+ *
+ * @tparam value and tangent type for variables
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+template <typename T>
+inline std::complex<stan::math::fvar<T>> operator*(
+    const std::complex<double>& x, const std::complex<stan::math::fvar<T>>& y) {
+  return internal::complex_multiply(x, y);
+}
+
+/**
+ * Return the product of std::complex<double> and
+ * std::complex<fvar<T>> arguments.
+ *
+ * @tparam value and tangent type for variables
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+template <typename T>
+inline std::complex<stan::math::fvar<T>> operator*(
+    const std::complex<stan::math::fvar<T>>& x, const std::complex<double>& y) {
+  return internal::complex_multiply(x, y);
+}
+
 }  // namespace math
 }  // namespace stan
 #endif
diff --git a/stan/lib/stan_math/rev/core/operator_multiplication.hpp b/stan/lib/stan_math/rev/core/operator_multiplication.hpp
index 6e0a81ea244..b5a1955cf49 100644
--- a/stan/lib/stan_math/rev/core/operator_multiplication.hpp
+++ b/stan/lib/stan_math/rev/core/operator_multiplication.hpp
@@ -5,6 +5,7 @@
 #include <stan/math/rev/core/var.hpp>
 #include <stan/math/rev/core/vv_vari.hpp>
 #include <stan/math/rev/core/vd_vari.hpp>
+#include <stan/math/prim/core/operator_multiplication.hpp>
 #include <stan/math/prim/fun/constants.hpp>
 #include <stan/math/prim/fun/is_any_nan.hpp>
 #include <stan/math/prim/fun/isinf.hpp>
@@ -112,6 +113,45 @@ inline var operator*(Arith a, const var& b) {
   return {new internal::multiply_vd_vari(b.vi_, a)};  // by symmetry
 }

+/**
+ * Return the product of std::complex<var> arguments.
+ *
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+inline std::complex<stan::math::var> operator*(
+    const std::complex<stan::math::var>& x,
+    const std::complex<stan::math::var>& y) {
+  return internal::complex_multiply(x, y);
+}
+
+/**
+ * Return the product of std::complex<double> and
+ * std::complex<var> arguments.
+ *
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+inline std::complex<stan::math::var> operator*(
+    const std::complex<double>& x, const std::complex<stan::math::var>& y) {
+  return internal::complex_multiply(x, y);
+}
+
+/**
+ * Return the product of std::complex<double> and
+ * std::complex<var> arguments.
+ *
+ * @param[in] x first argument
+ * @param[in] y second argument
+ * @return product of arguments
+ */
+inline std::complex<stan::math::var> operator*(
+    const std::complex<stan::math::var>& x, const std::complex<double>& y) {
+  return internal::complex_multiply(x, y);
+}
+
 }  // namespace math
 }  // namespace stan
 #endif
